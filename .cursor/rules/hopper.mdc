---
alwaysApply: true
---

# 料仓监控系统后端开发规则

## 项目标识

- **项目名称**: ceramic-hopper-backend
- **技术栈**: FastAPI + WebSocket + InfluxDB + Snap7
- **核心理念**: WebSocket 实时推送 + 本地 InfluxDB 部署 + 高可靠性轮询

## 架构原则

### 1. WebSocket 优先策略

- **实时推送**: 所有实时数据必须通过 WebSocket (`ws://host:port/ws/realtime`) 推送
- **推送间隔**: 0.1s (100ms) 极快响应
- **HTTP 降级**: HTTP API 仅用于历史数据查询和配置管理
- **连接管理**: 使用 `ws_manager.py` 统一管理连接、订阅和推送任务

### 2. 本地部署优先

- **InfluxDB**: 推荐本地安装，避免 Docker 网络延迟
- **配置**: `INFLUX_URL=http://localhost:8088`
- **性能**: 本地部署提供更快的数据写入和查询响应

### 3. 数据流架构

```
PLC/Mock → Polling Service (5s) → Memory Cache → WebSocket Push (0.1s) → Clients
                                 ↓
                            InfluxDB (批量写入) → HTTP Query
```

## 核心组件

### WebSocket 层

**文件**: `app/services/ws_manager.py`, `app/routers/websocket.py`

- **ConnectionManager**: 单例模式，管理所有 WebSocket 连接
- **订阅频道**: `realtime` (实时数据)
- **心跳机制**: 客户端 15s 发送，服务端 45s 超时断开
- **推送任务**: `asyncio.create_task()` 异步推送，避免阻塞

**消息模型**: `app/models/ws_messages.py`
- 使用 Pydantic v2 进行消息验证
- 所有消息必须包含 `type` 字段
- 消息类型: `subscribe`, `unsubscribe`, `heartbeat`, `realtime_data`, `error`

### 轮询服务层

**文件**: `app/services/polling_service.py`

- **轮询间隔**: 5 秒
- **内存缓存**: 全局变量缓存最新数据，供 WebSocket 推送使用
- **双重写入**: 
  1. 更新内存缓存 (实时推送)
  2. 批量写入 InfluxDB (历史查询)
- **错误隔离**: 单个设备失败不影响整体轮询

### PLC 通信层

**文件**: `app/plc/plc_manager.py`, `app/plc/parser_hopper_4.py`

- **连接管理**: 自动重连机制
- **数据解析**: 基于 YAML 配置的偏移量解析
- **Mock 模式**: `mock_mode=true` 时使用模拟数据

### 数据库层

**文件**: `app/core/influxdb.py`

- **Measurement**: `sensor_data`
- **Tags**: `device_id`, `device_type`, `module_type`
- **Fields**: 动态字段 (pm10, temperature, voltage, current, vibration, etc.)
- **批量写入**: 减少网络开销

## 设备数据结构

### 料仓传感器单元 (hopper_sensor_unit)

**设备**: 4号料仓综合监测单元 (`hopper_unit_4`)

**模块**:
1. **PM10 粉尘浓度** (`pm10`)
   - 字段: `pm10_value` (μg/m³)

2. **温度传感器** (`temperature`)
   - 字段: `temperature_value` (°C)

3. **三相电表** (`electricity`)
   - 字段: `Pt` (总功率), `ImpEp` (累计电量), `Ua_0`, `I_0`, `I_1`, `I_2` (电压电流)

4. **振动传感器** (`vibration_selected`)
   - 速度幅值: `vx`, `vy`, `vz`
   - 速度RMS: `vrms_x`, `vrms_y`, `vrms_z`
   - 波峰因素: `cf_x`, `cf_y`, `cf_z`
   - 峭度: `k_x`, `k_y`, `k_z`
   - 频率: `freq_x`, `freq_y`, `freq_z`
   - 温度: `temperature`
   - 故障诊断: `err_x`, `err_y`, `err_z`

## 编码规范

### 1. 命名规范

#### 1.1 基础命名规则

- **文件名**: 小写下划线 `snake_case.py`
- **类名**: 大驼峰 `PascalCase`
- **函数/变量**: 小写下划线 `snake_case`
- **常量**: 大写下划线 `UPPER_SNAKE_CASE`

### 2. 注释规范

**使用清晰的注释风格**：

```python
# 1. 初始化 WebSocket 连接管理器
def __init__(self):
    self.active_connections = {}
    self.last_heartbeat = {}

# 2. 处理客户端连接
async def connect(self, websocket: WebSocket):
    await websocket.accept()
    self.active_connections[websocket] = set()
```

**文件头部注释**：
```python
"""
WebSocket 连接管理器 - 管理所有客户端连接和消息推送
"""
```

#### 2.1 禁止使用 Emoji 表情符号

**原则**: 注释中不使用任何 emoji 图标或表情符号，保持代码的专业性和可读性。

正确的注释：
```python
# 1. 初始化连接管理器
# 注意：这里需要使用线程安全的数据结构
# 警告：不要在推送循环中执行阻塞操作
# 成功：数据推送完成
# 错误：连接断开
```

错误的注释（禁止使用）：
```python
# 初始化连接管理器
# 注意：这里需要使用线程安全的数据结构
# 错误：连接断开
# 成功：数据推送完成
# 重要：性能优化
# 提示：可以使用缓存
```

**原因说明**：
1. **编码兼容性**: Emoji 可能在某些编辑器或终端中显示异常
2. **代码审查**: 纯文本注释更易于代码审查和搜索
3. **专业性**: 工业控制系统代码应保持严谨的专业风格
4. **版本控制**: Emoji 在 Git diff 中可能显示为乱码
5. **跨平台**: 不同操作系统对 Emoji 的支持程度不同

### 3. 代码设计原则

**避免过度抽象**：
- **不要提前抽象**：需要用的时候再抽象，不要一开始就创建大量工具方法
- **避免冗余方法**：一个文件不要抽象出太多方法，保持简洁
- **实用主义**：能直接写就直接写，不要为了"优雅"而过度封装

好的做法：
```python
# 1. 推送实时数据
async def push_realtime_data(self, timestamp: str):
    latest = get_latest_data()
    message = {
        "type": "realtime_data",
        "timestamp": timestamp,
        "data": latest
    }
    await self.broadcast("realtime", message)
```

过度抽象：
```python
def _format_timestamp(self, ts):
    return ts

def _create_message_header(self, msg_type):
    return {"type": msg_type}

def _add_timestamp(self, msg, ts):
    msg["timestamp"] = ts
    return msg

async def push_realtime_data(self, timestamp: str):
    latest = get_latest_data()
    header = self._create_message_header("realtime_data")
    message = self._add_timestamp(header, self._format_timestamp(timestamp))
    message["data"] = latest
    await self.broadcast("realtime", message)
```

### 4. WebSocket 代码规范

```python
# 正确：处理连接断开
try:
    await websocket.send_json(message)
except WebSocketDisconnect:
    manager.disconnect(websocket)
except Exception as e:
    logger.warning(f"发送失败: {e}")
    manager.disconnect(websocket)

# 正确：检查连接状态
if ws.application_state != WebSocketState.CONNECTED:
    manager.disconnect(ws)
    return

# 错误：不处理异常
await websocket.send_json(message)  # 可能导致服务崩溃
```

### 5. 异步任务规范

```python
# 正确：使用 asyncio.create_task
self._push_task = asyncio.create_task(self._push_loop())

# 正确：优雅停止任务
if self._push_task:
    self._push_task.cancel()
    try:
        await self._push_task
    except asyncio.CancelledError:
        pass

# 错误：直接 await 会阻塞
await self._push_loop()  # 会阻塞主线程
```

### 6. 内存缓存规范

```python
# 正确：使用全局缓存
_latest_data: Dict[str, Any] = {}

def get_latest_data() -> Dict[str, Any]:
    return _latest_data.copy()

# 正确：线程安全更新
def update_cache(device_id: str, data: dict):
    _latest_data[device_id] = data

# 错误：每次查询数据库
data = query_influxdb()  # 性能差
```

### 7. 日志规范

```python
# 正确：WebSocket 日志
logger.info(f"[WS] 新连接建立，当前连接数: {count}")
logger.debug(f"[WS] 推送 realtime_data -> {subs} 个订阅者")
logger.warning(f"[WS] 客户端心跳超时 ({delta:.0f}s)")

# 正确：错误日志包含 traceback
logger.error(f"[WS] 推送任务异常: {e}", exc_info=True)

# 错误：缺少上下文
logger.error("错误")  # 无法定位问题
```

### 8. 配置驱动规范

```python
# 正确：从 YAML 读取配置
config = load_yaml("configs/config_hopper_4.yaml")
offset = config["modules"][0]["offset"]

# 错误：硬编码
offset = 0  # 难以维护
```

## API 接口规范

### WebSocket 接口 (主要)

**端点**: `ws://localhost:8080/ws/realtime`

**客户端消息**:
```json
{"type": "subscribe", "channel": "realtime"}
{"type": "heartbeat", "timestamp": "2026-02-09T10:30:00Z"}
```

**服务端推送**:
```json
{
  "type": "realtime_data",
  "success": true,
  "timestamp": "2026-02-09T10:30:00.000Z",
  "source": "plc",
  "data": {
    "hopper_unit_4": {
      "device_id": "hopper_unit_4",
      "device_name": "4号料仓综合监测单元",
      "device_type": "hopper_sensor_unit",
      "timestamp": "2026-02-09T10:30:00.000Z",
      "modules": {
        "pm10": {
          "module_type": "pm10",
          "fields": {"pm10_value": 45.2}
        },
        "temperature": {
          "module_type": "temperature",
          "fields": {"temperature_value": 28.5}
        },
        "electricity": {
          "module_type": "electricity",
          "fields": {
            "Pt": 5.6,
            "ImpEp": 1234.5,
            "Ua_0": 380.5,
            "I_0": 12.3,
            "I_1": 12.1,
            "I_2": 12.4
          }
        },
        "vibration_selected": {
          "module_type": "vibration_selected",
          "fields": {
            "vx": 2.3,
            "vy": 2.1,
            "vz": 1.8,
            "vrms_x": 1.5,
            "vrms_y": 1.4,
            "vrms_z": 1.2,
            "freq_x": 50.2,
            "freq_y": 50.1,
            "freq_z": 50.3,
            "temperature": 45.6
          }
        }
      }
    }
  }
}
```

### HTTP 接口 (降级)

**端点**: `http://localhost:8080/api`

- `GET /hopper/realtime/batch`: 批量实时数据
- `GET /hopper/{device_id}/history`: 历史数据查询
- `GET /health`: 健康检查
- `GET /ws/status`: WebSocket 连接统计

## 性能优化

### 1. 内存缓存优先

```python
# 优先级 1: 内存缓存 (最快)
cached_data = get_latest_data()

# 优先级 2: Mock 数据 (开发模式)
if settings.mock_mode:
    data = MockService.generate_hopper_data()

# 优先级 3: InfluxDB 查询 (降级)
data = query_data(measurement="sensor_data", ...)
```

### 2. 批量写入

```python
# 正确：批量写入 InfluxDB
points = []
for device_id, data in devices.items():
    points.append(Point("sensor_data").tag("device_id", device_id).field("pm10_value", data["pm10"]))
write_api.write(bucket=bucket, record=points)

# 错误：逐条写入
for device_id, data in devices.items():
    write_api.write(...)  # 性能差
```

### 3. 异步推送

```python
# 正确：异步推送，不阻塞
async def broadcast(self, channel: str, message: dict):
    tasks = []
    for ws, channels in self.active_connections.items():
        if channel in channels:
            tasks.append(ws.send_json(message))
    await asyncio.gather(*tasks, return_exceptions=True)

# 错误：同步推送，阻塞
for ws in connections:
    await ws.send_json(message)  # 串行执行
```

## 错误处理

### 1. WebSocket 错误

```python
# 必须处理的异常
try:
    await websocket.send_json(message)
except WebSocketDisconnect:
    # 客户端主动断开
    manager.disconnect(websocket)
except RuntimeError as e:
    # 连接已关闭
    if "WebSocket is not connected" in str(e):
        manager.disconnect(websocket)
except Exception as e:
    # 其他未知错误
    logger.error(f"发送失败: {e}", exc_info=True)
    manager.disconnect(websocket)
```

### 2. 轮询错误

```python
# 正确：宽泛的异常捕获，防止服务崩溃
while is_running():
    try:
        data = await poll_plc()
        update_cache(data)
    except Exception as e:
        logger.error(f"轮询异常: {e}", exc_info=True)
        await asyncio.sleep(5)  # 继续运行
```

### 3. 数据库错误

```python
# 正确：降级到本地缓存
try:
    write_api.write(bucket=bucket, record=points)
except Exception as e:
    logger.error(f"InfluxDB 写入失败: {e}")
    # 降级到 SQLite 本地缓存
    local_cache.save(points)
```

## 开发流程

### 1. 启动服务

```bash
# 本地开发 (推荐)
uvicorn main:create_app --factory --host 0.0.0.0 --port 8080 --reload

# Mock 模式
python main.py

# 生产模式
mock_mode=false python main.py
```

### 2. 测试 WebSocket

```bash
# 使用 websocat 测试
websocat ws://localhost:8080/ws/realtime

# 发送订阅消息
{"type": "subscribe", "channel": "realtime"}

# 发送心跳
{"type": "heartbeat", "timestamp": "2026-02-09T10:30:00Z"}
```

### 3. 查看日志

```bash
# 查看 WebSocket 连接日志
grep "[WS]" logs/app.log

# 查看推送日志
grep "推送" logs/app.log
```

## 常见问题

### 1. WebSocket 连接断开

**原因**: 心跳超时、网络中断、客户端崩溃

**解决**:
- 检查客户端心跳间隔 (应 < 45s)
- 实现客户端重连机制 (指数退避)
- 查看服务端日志 `[WS]` 标记

### 2. 推送延迟高

**原因**: 推送间隔过大、数据库查询慢、内存缓存未命中

**解决**:
- 检查 `PUSH_INTERVAL` 配置 (默认 0.1s)
- 确保轮询服务正常运行
- 优先使用内存缓存，避免查询数据库

### 3. 内存持续增长

**原因**: WebSocket 连接未清理、缓存无限增长

**解决**:
- 检查 `disconnect()` 是否正确调用
- 实现心跳超时清理机制
- 限制缓存大小 (如只保留最新 1000 条)

### 4. InfluxDB 连接失败

**原因**: 服务未启动、端口错误、认证失败

**解决**:
- 检查 InfluxDB 服务状态
- 确认 `INFLUX_URL=http://localhost:8088`
- 验证 Token 和 Bucket 配置

## 文件结构速查

```
ceramic-hopper-backend/
├── main.py                           # 入口 (Lifespan 管理)
├── config.py                         # 全局配置
├── configs/                          # YAML 配置文件
│   ├── config_hopper_4.yaml          # 料仓设备数据点映射
│   ├── db_mappings.yaml              # DB 块映射
│   └── plc_modules.yaml              # 模块定义
├── app/
│   ├── models/
│   │   ├── ws_messages.py            # WebSocket 消息模型
│   │   └── response.py               # HTTP 响应模型
│   ├── services/
│   │   ├── ws_manager.py             # WebSocket 连接管理器
│   │   ├── polling_service.py        # 轮询服务
│   │   └── mock_service.py           # Mock 数据生成
│   ├── routers/
│   │   ├── websocket.py              # WebSocket 路由
│   │   ├── hopper_4.py               # HTTP 实时数据接口
│   │   ├── health.py                 # 健康检查
│   │   ├── config.py                 # 配置管理
│   │   └── alarms.py                 # 报警管理
│   ├── plc/
│   │   ├── plc_manager.py            # PLC 连接管理
│   │   └── parser_hopper_4.py        # 数据解析器
│   └── core/
│       ├── influxdb.py               # InfluxDB 封装
│       └── local_cache.py            # SQLite 降级缓存
└── docs/
    └── WEBSOCKET_PROTOCOL.md         # WebSocket 协议规范
```

## AI 编码指令

1. **WebSocket 优先**: 实时数据推送必须使用 WebSocket，HTTP 仅作降级
2. **本地部署**: 推荐本地 InfluxDB，避免 Docker 延迟
3. **内存缓存**: 优先使用内存缓存，减少数据库查询
4. **异常处理**: 所有 I/O 操作必须有异常处理和重试机制
5. **连接管理**: WebSocket 连接必须正确处理断开、超时和重连
6. **批量写入**: InfluxDB 写入使用批量模式，减少网络开销
7. **异步推送**: 使用 `asyncio.create_task()` 异步推送，避免阻塞
8. **日志规范**: 关键操作必须记录日志，错误日志包含 traceback
9. **配置驱动**: 优先修改 YAML 配置，避免硬编码
10. **协议规范**: 严格遵循 `docs/WEBSOCKET_PROTOCOL.md` 定义的消息格式

## 参考文档

- `docs/WEBSOCKET_PROTOCOL.md` - WebSocket 协议规范
- `README.md` - 项目说明
- `configs/*.yaml` - 设备配置文件

## 其他规范

- **PowerShell 命令**：不支持 `&&`，使用分号 `;` 分隔命令
- **称呼**：每次回答必须称呼我为"大王"
- **测试文件**：不要创建多余的 md/py/test 文件，测试完毕后一定要删除,并且我的任何测试代码不要使用 emoji.
- **文档管理**：md 文件需要放到 `vdoc/` 目录里面
- **代码整洁**：目录务必整洁，修改代码时删除旧代码，不要冗余
- **回答执行规范**：你是一个很严格的 Python FastAPI 后端开发高手,你很严谨认真,且对代码很严苛,不会写无用冗余代码,并且很多问题,对于我希望实现的效果和架构你会认真思考,如果我的提议不好或者你有更好的方案,你会规劝我.
- **反驳我的回答** 对于我说的需求等的话,肯定会有一些东西说的不专业,如果你理解了的话,就回答我,"大王,小的罪该万死,但是这个XXXX"这样回答.
- **编码问题** 我的代码文件肯定会就是有中文和python代码,以及可能会有图标,所以的话,生成的代码需要规避编码问题错误.
- **log以及代码文件** 我的代码文件以及log的输出的话,等一切不要使用图标等标注.
- **不要虚构** 回答我以及生成的md文件之中一定要和我的实际的代码文件相关,而不是虚构的.
- **不使用虚拟环境启动python**
- **必须真实有效的回答我,不能虚构**不要虚构任何我项目没有的文件,回答也必须严谨有效,而不是虚构.
- **测试脚本和启动脚本文件最小化原则**尽量不要创建脚本而是直接给我一组命令行就行,如果需要保留为脚本我会提创建脚本的需求.
-**我的.env文件的编辑不用你来修改直接给个我文件内容,我自己复制就行**
